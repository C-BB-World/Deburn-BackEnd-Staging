# Session Log - 16/01/26

## Firebase Auth Environment Variable Support

Updated `common/auth/firebase_auth.py` to automatically detect and use Firebase credentials from environment variables.

### Changes Made

**1. Added `_get_firebase_credentials_from_env()` helper function**
- Checks if required Firebase fields (`PROJECT_ID`, `PRIVATE_KEY`, `CLIENT_EMAIL`) are present in environment
- Builds complete credentials dict from all Firebase env vars if present
- Returns `None` if required fields are missing, allowing fallback to other methods

**2. Updated `FirebaseAuth.__init__()` initialization logic**
- Now checks environment variables as a fallback when no explicit credentials are provided
- Priority order: `credentials_path` > `credentials_dict` > environment variables > `ApplicationDefault()`

**3. Added `python-dotenv` support**
- Added try/except block to load `.env` file using `python-dotenv` if available
- Gracefully falls back to system environment variables if dotenv not installed

**4. Updated `requirements.txt`**
- Added `python-dotenv>=1.0.0` dependency

### Files Modified
- `common/auth/firebase_auth.py`
- `requirements.txt`

### Result
`FirebaseAuth()` can now be instantiated without arguments and will automatically pick up Firebase credentials from the `.env` file, making initialization in `app_v2/dependencies.py` work seamlessly.

---

## API Schema Updates

Updated all API schemas and routers to match the frontend API documentation in `docs/v2/architecture/api/`.

### Changes Made

**Schemas updated to match API docs:**
- `app_v2/schemas/auth.py` - Login/Register now accept email/password instead of Firebase token
- `app_v2/schemas/checkin.py` - Simplified to match docs
- `app_v2/schemas/circles.py` - Availability slots now use `{dayOfWeek, startTime, endTime}` format
- `app_v2/schemas/dashboard.py` - Created new schema file
- `app_v2/schemas/progress.py` - Simplified insights format
- `app_v2/schemas/learning.py` - Created new schema file
- `app_v2/schemas/profile.py` - Created new schema file
- `app_v2/schemas/hub.py` - Simplified to match docs
- `app_v2/schemas/admin.py` - Created new schema file

**Routers updated:**
- All routers now use `success_response()` wrapper consistently
- Response formats match the API documentation exactly
- Fixed 422 validation errors caused by schema mismatches

### Files Modified
- All files in `app_v2/schemas/`
- All files in `app_v2/routers/`

---

## TODO: Coach/AI Endpoints

The following coach/AI endpoints exist in the API docs but were **intentionally not implemented** as they may be replaced with a different AI agent system:

- `POST /api/coach/stream` - Streaming AI coach response (SSE)
- `POST /api/coach/chat` - Non-streaming chat endpoint
- `GET /api/coach/starters` - Conversation starter suggestions
- `GET /api/coach/history` - Conversation history
- `POST /api/coach/feedback` - Message feedback
- `GET /api/coach/exercises` - Available exercises

These endpoints are documented in `docs/v2/architecture/api/coach.md` for reference when implementing the AI system.

---

## Firebase REST API Authentication

Added support for email/password authentication using Firebase REST API.

### Changes Made

**1. Updated `common/auth/firebase_auth.py`**
- Added `sign_in_with_password(email, password)` method using Firebase REST API
- Updated `verify_credentials()` to use the new method
- Added `FIREBASE_API_KEY` environment variable support
- Uses `httpx` for async HTTP requests to Firebase REST API

**2. Updated `app_v2/routers/auth.py`**
- Login now uses `sign_in_with_password()` instead of non-existent `verify_password()`
- Register validates password confirmation before creating user
- Both endpoints have proper error handling

### Required Environment Variable

Add to your `.env` file:
```
FIREBASE_API_KEY=your-firebase-web-api-key
```

Find this in Firebase Console → Project Settings → General → Web API Key.

---

## Email Service Implementation

Added email service for sending transactional emails (verification, password reset).

### Changes Made

**1. Created `app_v2/services/email/email_service.py`**
- Multi-mode support: `console` (development) and `resend` (production)
- `send_verification_email()` - Sends email verification with link
- `send_password_reset_email()` - Sends password reset with link
- Uses httpx for Resend API calls
- HTML and plain text email templates

**2. Updated `app_v2/routers/auth.py`**
- Register endpoint now sends verification email after user creation
- Forgot-password endpoint generates and sends reset link
- Resend-verification endpoint generates and sends new verification link
- All endpoints handle errors gracefully without revealing user existence

**3. Updated `requirements.txt`**
- Added `resend>=2.0.0` dependency

### Environment Variables

For production with Resend API:
```
EMAIL_MODE=resend
RESEND_API_KEY=re_your_api_key
SMTP_FROM_EMAIL=noreply@yourdomain.com
SMTP_FROM_NAME=Deburn
APP_URL=https://app.yourdomain.com
```

For development (emails logged to console):
```
EMAIL_MODE=console
```

### Email Flow

1. User registers → Firebase creates user → Generate verification link → Send email
2. User forgot password → Generate reset link → Send email
3. User requests verification resend → Generate new link → Send email

---

## Email Service - SMTP Mode with Resend API Key

Updated email service to match original deburnalpha behavior: when `EMAIL_MODE=smtp` and `SMTP_PASSWORD` contains a Resend API key, use Resend HTTP API instead of actual SMTP.

### Changes Made

**Updated `app_v2/services/email/email_service.py`**
- `SMTP_PASSWORD` now treated as fallback for `RESEND_API_KEY`
- When `EMAIL_MODE=smtp` and API key is available, normalizes to `resend` mode
- Added SMTP support via `aiosmtplib` for actual SMTP servers
- Improved logging to show which mode is active

### Environment Variables

With existing config (no changes needed):
```
EMAIL_MODE=smtp
SMTP_PASSWORD=re_your_resend_api_key
SMTP_FROM_EMAIL=noreply@yourdomain.com
```

The service auto-detects the Resend API key and uses HTTP API.

---

## Registration Consent Version Fix

Fixed 422 error during registration caused by missing consent version.

### Issue

The `ConsentService.validate_registration_consents()` method requires each consent to have a `version` field matching the current version (`"1.0"`). The auth router was not including this field.

### Fix

Updated `app_v2/routers/auth.py` to include version in consents:
```python
consents=[
    {"type": "termsOfService", "accepted": True, "version": "1.0"},
    {"type": "privacyPolicy", "accepted": True, "version": "1.0"},
    {"type": "dataProcessing", "accepted": True, "version": "1.0"},
    {"type": "marketing", "accepted": False, "version": "1.0"},
]
```

---

## Known Issues / TODO

### Duplicate User Handling

The current registration flow creates user in Firebase BEFORE checking MongoDB for duplicates. This can result in:
- Orphaned Firebase users if MongoDB insert fails
- Confusing errors when re-registering with same email

**Recommended fix**: Check for existing email in MongoDB BEFORE creating Firebase user (as done in original deburnalpha `authService.js` lines 42-45).

### Login - User Not in Database

If a user exists in Firebase but not in MongoDB (due to partial registration), login returns 401 "User not found". Options:
1. Auto-create MongoDB user on login if Firebase auth succeeds
2. Show clearer error message to user
3. Provide admin tool to sync Firebase/MongoDB users

---

## Session Token Authentication Implementation

Implemented Bearer token authentication for API requests. This enables the frontend and backend to be deployed on separate domains (e.g., separate Render instances).

### Problem

- Frontend was getting `AUTH_REQUIRED` errors on protected endpoints
- The backend `login` endpoint created sessions but never returned the token
- Frontend had no way to authenticate subsequent requests
- Cookie-based auth doesn't work reliably across different domains

### Solution

Implemented Authorization header-based authentication:
1. Backend returns session token after login
2. Frontend stores token in localStorage
3. Frontend sends `Authorization: Bearer <token>` header with every request
4. Backend middleware validates token (already implemented)

### Changes Made

**Backend: `app_v2/routers/auth.py`**
- Capture token and expiry from `session_manager.create_session()`
- Return `token` and `expiresAt` in login response

```python
# Before:
session = await session_manager.create_session(...)
return success_response({"user": {...}})

# After:
token, expires_at = await session_manager.create_session(...)
return success_response({
    "user": {...},
    "token": token,
    "expiresAt": expires_at.isoformat()
})
```

**Frontend: `src/utils/api.js`**
- Added `authToken` module-level variable
- Added `setAuthToken(token)`, `clearAuthToken()`, `getAuthToken()` functions
- Modified `apiRequest()` to include `Authorization: Bearer <token>` header when token exists

**Frontend: `src/context/AuthContext.jsx`**
- Import `setAuthToken`, `clearAuthToken` from api.js
- On mount: Load token from localStorage, call `setAuthToken()`
- On login: Store token in localStorage, call `setAuthToken()`
- On logout: Remove token from localStorage, call `clearAuthToken()`

### Files Modified

- `app_v2/routers/auth.py` - Return token in login response
- `Deburn-FrontEnd/src/utils/api.js` - Token management and Authorization header
- `Deburn-FrontEnd/src/context/AuthContext.jsx` - Token storage in localStorage

### Also Fixed

**VITE_ENDPOINT URL Doubling Bug**
- Multiple frontend files were using `${import.meta.env.VITE_ENDPOINT}/api/...` directly
- But `api.js` already adds `VITE_API_URL` as base URL via `getApiBaseUrl()`
- This caused doubled URLs like `http://localhost:5002http://localhost:5002/api/checkin`
- Fixed all files to use relative paths (e.g., `/api/checkin`)

Files fixed:
- `src/pages/Checkin.jsx`
- `src/pages/Dashboard.jsx`
- `src/pages/Progress.jsx`
- `src/pages/Admin.jsx`
- `src/pages/Learning.jsx`
- `src/pages/Profile.jsx`
- `src/pages/auth/VerifyEmail.jsx`
- `src/pages/auth/ForgotPassword.jsx`
- `src/pages/auth/ResetPassword.jsx`
- `src/features/circles/circlesApi.js`
- `src/features/coach/coachApi.js`
- `src/features/hub/hubApi.js`

### Authentication Flow

1. User logs in → Backend returns `{ user, token, expiresAt }`
2. Frontend stores token in localStorage (`deburn_auth_token`)
3. Frontend sets token in memory via `setAuthToken()`
4. Every API request includes `Authorization: Bearer <token>` header
5. Backend middleware extracts token, hashes it, validates against MongoDB
6. On logout → Clear localStorage and memory token

### Deployment Note

This approach works for:
- Same-origin deployments (frontend and backend on same domain)
- Cross-origin deployments (frontend and backend on different domains/Render instances)

No CORS cookie issues since authentication uses headers, not cookies.
