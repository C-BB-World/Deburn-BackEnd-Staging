# Session Log - 16/01/26

## Firebase Auth Environment Variable Support

Updated `common/auth/firebase_auth.py` to automatically detect and use Firebase credentials from environment variables.

### Changes Made

**1. Added `_get_firebase_credentials_from_env()` helper function**
- Checks if required Firebase fields (`PROJECT_ID`, `PRIVATE_KEY`, `CLIENT_EMAIL`) are present in environment
- Builds complete credentials dict from all Firebase env vars if present
- Returns `None` if required fields are missing, allowing fallback to other methods

**2. Updated `FirebaseAuth.__init__()` initialization logic**
- Now checks environment variables as a fallback when no explicit credentials are provided
- Priority order: `credentials_path` > `credentials_dict` > environment variables > `ApplicationDefault()`

**3. Added `python-dotenv` support**
- Added try/except block to load `.env` file using `python-dotenv` if available
- Gracefully falls back to system environment variables if dotenv not installed

**4. Updated `requirements.txt`**
- Added `python-dotenv>=1.0.0` dependency

### Files Modified
- `common/auth/firebase_auth.py`
- `requirements.txt`

### Result
`FirebaseAuth()` can now be instantiated without arguments and will automatically pick up Firebase credentials from the `.env` file, making initialization in `app_v2/dependencies.py` work seamlessly.

---

## API Schema Updates

Updated all API schemas and routers to match the frontend API documentation in `docs/v2/architecture/api/`.

### Changes Made

**Schemas updated to match API docs:**
- `app_v2/schemas/auth.py` - Login/Register now accept email/password instead of Firebase token
- `app_v2/schemas/checkin.py` - Simplified to match docs
- `app_v2/schemas/circles.py` - Availability slots now use `{dayOfWeek, startTime, endTime}` format
- `app_v2/schemas/dashboard.py` - Created new schema file
- `app_v2/schemas/progress.py` - Simplified insights format
- `app_v2/schemas/learning.py` - Created new schema file
- `app_v2/schemas/profile.py` - Created new schema file
- `app_v2/schemas/hub.py` - Simplified to match docs
- `app_v2/schemas/admin.py` - Created new schema file

**Routers updated:**
- All routers now use `success_response()` wrapper consistently
- Response formats match the API documentation exactly
- Fixed 422 validation errors caused by schema mismatches

### Files Modified
- All files in `app_v2/schemas/`
- All files in `app_v2/routers/`

---

## TODO: Coach/AI Endpoints

The following coach/AI endpoints exist in the API docs but were **intentionally not implemented** as they may be replaced with a different AI agent system:

- `POST /api/coach/stream` - Streaming AI coach response (SSE)
- `POST /api/coach/chat` - Non-streaming chat endpoint
- `GET /api/coach/starters` - Conversation starter suggestions
- `GET /api/coach/history` - Conversation history
- `POST /api/coach/feedback` - Message feedback
- `GET /api/coach/exercises` - Available exercises

These endpoints are documented in `docs/v2/architecture/api/coach.md` for reference when implementing the AI system.

---

## Firebase REST API Authentication

Added support for email/password authentication using Firebase REST API.

### Changes Made

**1. Updated `common/auth/firebase_auth.py`**
- Added `sign_in_with_password(email, password)` method using Firebase REST API
- Updated `verify_credentials()` to use the new method
- Added `FIREBASE_API_KEY` environment variable support
- Uses `httpx` for async HTTP requests to Firebase REST API

**2. Updated `app_v2/routers/auth.py`**
- Login now uses `sign_in_with_password()` instead of non-existent `verify_password()`
- Register validates password confirmation before creating user
- Both endpoints have proper error handling

### Required Environment Variable

Add to your `.env` file:
```
FIREBASE_API_KEY=your-firebase-web-api-key
```

Find this in Firebase Console → Project Settings → General → Web API Key.

---

## Email Service Implementation

Added email service for sending transactional emails (verification, password reset).

### Changes Made

**1. Created `app_v2/services/email/email_service.py`**
- Multi-mode support: `console` (development) and `resend` (production)
- `send_verification_email()` - Sends email verification with link
- `send_password_reset_email()` - Sends password reset with link
- Uses httpx for Resend API calls
- HTML and plain text email templates

**2. Updated `app_v2/routers/auth.py`**
- Register endpoint now sends verification email after user creation
- Forgot-password endpoint generates and sends reset link
- Resend-verification endpoint generates and sends new verification link
- All endpoints handle errors gracefully without revealing user existence

**3. Updated `requirements.txt`**
- Added `resend>=2.0.0` dependency

### Environment Variables

For production with Resend API:
```
EMAIL_MODE=resend
RESEND_API_KEY=re_your_api_key
SMTP_FROM_EMAIL=noreply@yourdomain.com
SMTP_FROM_NAME=Deburn
APP_URL=https://app.yourdomain.com
```

For development (emails logged to console):
```
EMAIL_MODE=console
```

### Email Flow

1. User registers → Firebase creates user → Generate verification link → Send email
2. User forgot password → Generate reset link → Send email
3. User requests verification resend → Generate new link → Send email

---

## Email Service - SMTP Mode with Resend API Key

Updated email service to match original deburnalpha behavior: when `EMAIL_MODE=smtp` and `SMTP_PASSWORD` contains a Resend API key, use Resend HTTP API instead of actual SMTP.

### Changes Made

**Updated `app_v2/services/email/email_service.py`**
- `SMTP_PASSWORD` now treated as fallback for `RESEND_API_KEY`
- When `EMAIL_MODE=smtp` and API key is available, normalizes to `resend` mode
- Added SMTP support via `aiosmtplib` for actual SMTP servers
- Improved logging to show which mode is active

### Environment Variables

With existing config (no changes needed):
```
EMAIL_MODE=smtp
SMTP_PASSWORD=re_your_resend_api_key
SMTP_FROM_EMAIL=noreply@yourdomain.com
```

The service auto-detects the Resend API key and uses HTTP API.

---

## Registration Consent Version Fix

Fixed 422 error during registration caused by missing consent version.

### Issue

The `ConsentService.validate_registration_consents()` method requires each consent to have a `version` field matching the current version (`"1.0"`). The auth router was not including this field.

### Fix

Updated `app_v2/routers/auth.py` to include version in consents:
```python
consents=[
    {"type": "termsOfService", "accepted": True, "version": "1.0"},
    {"type": "privacyPolicy", "accepted": True, "version": "1.0"},
    {"type": "dataProcessing", "accepted": True, "version": "1.0"},
    {"type": "marketing", "accepted": False, "version": "1.0"},
]
```

---

## Known Issues / TODO

### Duplicate User Handling

The current registration flow creates user in Firebase BEFORE checking MongoDB for duplicates. This can result in:
- Orphaned Firebase users if MongoDB insert fails
- Confusing errors when re-registering with same email

**Recommended fix**: Check for existing email in MongoDB BEFORE creating Firebase user (as done in original deburnalpha `authService.js` lines 42-45).

### Login - User Not in Database

If a user exists in Firebase but not in MongoDB (due to partial registration), login returns 401 "User not found". Options:
1. Auto-create MongoDB user on login if Firebase auth succeeds
2. Show clearer error message to user
3. Provide admin tool to sync Firebase/MongoDB users

---

## Session Token Authentication Implementation

Implemented Bearer token authentication for API requests. This enables the frontend and backend to be deployed on separate domains (e.g., separate Render instances).

### Problem

- Frontend was getting `AUTH_REQUIRED` errors on protected endpoints
- The backend `login` endpoint created sessions but never returned the token
- Frontend had no way to authenticate subsequent requests
- Cookie-based auth doesn't work reliably across different domains

### Solution

Implemented Authorization header-based authentication:
1. Backend returns session token after login
2. Frontend stores token in localStorage
3. Frontend sends `Authorization: Bearer <token>` header with every request
4. Backend middleware validates token (already implemented)

### Changes Made

**Backend: `app_v2/routers/auth.py`**
- Capture token and expiry from `session_manager.create_session()`
- Return `token` and `expiresAt` in login response

```python
# Before:
session = await session_manager.create_session(...)
return success_response({"user": {...}})

# After:
token, expires_at = await session_manager.create_session(...)
return success_response({
    "user": {...},
    "token": token,
    "expiresAt": expires_at.isoformat()
})
```

**Frontend: `src/utils/api.js`**
- Added `authToken` module-level variable
- Added `setAuthToken(token)`, `clearAuthToken()`, `getAuthToken()` functions
- Modified `apiRequest()` to include `Authorization: Bearer <token>` header when token exists

**Frontend: `src/context/AuthContext.jsx`**
- Import `setAuthToken`, `clearAuthToken` from api.js
- On mount: Load token from localStorage, call `setAuthToken()`
- On login: Store token in localStorage, call `setAuthToken()`
- On logout: Remove token from localStorage, call `clearAuthToken()`

### Files Modified

- `app_v2/routers/auth.py` - Return token in login response
- `Deburn-FrontEnd/src/utils/api.js` - Token management and Authorization header
- `Deburn-FrontEnd/src/context/AuthContext.jsx` - Token storage in localStorage

### Also Fixed

**VITE_ENDPOINT URL Doubling Bug**
- Multiple frontend files were using `${import.meta.env.VITE_ENDPOINT}/api/...` directly
- But `api.js` already adds `VITE_API_URL` as base URL via `getApiBaseUrl()`
- This caused doubled URLs like `http://localhost:5002http://localhost:5002/api/checkin`
- Fixed all files to use relative paths (e.g., `/api/checkin`)

Files fixed:
- `src/pages/Checkin.jsx`
- `src/pages/Dashboard.jsx`
- `src/pages/Progress.jsx`
- `src/pages/Admin.jsx`
- `src/pages/Learning.jsx`
- `src/pages/Profile.jsx`
- `src/pages/auth/VerifyEmail.jsx`
- `src/pages/auth/ForgotPassword.jsx`
- `src/pages/auth/ResetPassword.jsx`
- `src/features/circles/circlesApi.js`
- `src/features/coach/coachApi.js`
- `src/features/hub/hubApi.js`

### Authentication Flow

1. User logs in → Backend returns `{ user, token, expiresAt }`
2. Frontend stores token in localStorage (`deburn_auth_token`)
3. Frontend sets token in memory via `setAuthToken()`
4. Every API request includes `Authorization: Bearer <token>` header
5. Backend middleware extracts token, hashes it, validates against MongoDB
6. On logout → Clear localStorage and memory token

### Deployment Note

This approach works for:
- Same-origin deployments (frontend and backend on same domain)
- Cross-origin deployments (frontend and backend on different domains/Render instances)

No CORS cookie issues since authentication uses headers, not cookies.

---

## Dashboard Streak Method Fix

Fixed `AttributeError: 'CheckInAnalytics' object has no attribute 'get_streak'` in dashboard endpoint.

### Issue

The dashboard router was calling `get_streak()` but the actual method in `CheckInAnalytics` is named `calculate_streak()`.

### Fix

Updated `app_v2/routers/dashboard.py`:
```python
# Before:
streak = await checkin_analytics.get_streak(user_id)

# After:
streak = await checkin_analytics.calculate_streak(user_id)
```

---

## Learning Modules - Hub Database Connection Fix

Fixed issue where the Learning tab showed no modules despite data existing in MongoDB.

### Problem

The API endpoint `/api/learning/modules` was returning `{"success":true,"data":{"modules":[]}}` even though content existed in the `deburn-hub.contentitems` collection.

### Root Cause

Two issues were found:

1. **Collection name case sensitivity**: `HubContentService` was using `hub_db["contentItems"]` (camelCase) but the actual MongoDB collection is `contentitems` (lowercase).

2. **Wrong database name**: The `HUB_MONGODB_DATABASE` setting in `app_v1/config.py` defaults to `"brainbank_hub"`, but the actual database is named `"deburn-hub"`. The `.env` file had `HUB_MONGODB_URI` but was missing the `HUB_MONGODB_DATABASE` variable.

### Fixes

**1. Fixed collection name in `app_v2/services/hub/hub_content_service.py`:**
```python
# Before:
self._content_collection = hub_db["contentItems"]

# After:
self._content_collection = hub_db["contentitems"]
```

**2. Added `HUB_MONGODB_DATABASE` to `.env`:**
```
HUB_MONGODB_DATABASE=deburn-hub
```

### Files Modified

- `app_v2/services/hub/hub_content_service.py` - Fixed collection name
- `.env` - Added `HUB_MONGODB_DATABASE=deburn-hub`

### Note

Restart the backend server after making these changes for the new environment variable to take effect.

---

## Learning Modules - MongoDB Sort Memory Limit Fix

Fixed `pymongo.errors.OperationFailure: Sort exceeded memory limit of 33554432 bytes` error.

### Problem

After fixing the database connection, the `/api/learning/modules` endpoint threw a MongoDB error because the sort operation exceeded the 32MB memory limit (MongoDB Atlas free tier limitation).

### Root Cause

The `contentitems` collection stores audio files as binary data (`audioDataEn`, `audioDataSv`) directly in documents. When MongoDB sorts, it loads all matching documents into memory - including multi-megabyte audio blobs - which exceeds the 32MB limit.

### Solution

Following the pattern from `deburnalpha/models/hub/ContentItem.js`, added projections to exclude binary audio fields before sorting:

```python
# Exclude binary audio data to avoid MongoDB 32MB sort memory limit
projection = {"audioDataEn": 0, "audioDataSv": 0}
cursor = self._content_collection.find(query, projection)
cursor = cursor.sort("sortOrder", 1)
```

### Files Modified

- `app_v2/services/hub/hub_content_service.py`
  - `get_all()` - Added projection to exclude audio data
  - `get_published()` - Added projection to exclude audio data
  - `get_for_coach()` - Added projection to exclude audio data

### Note

Audio data is still available via the separate `get_audio()` method which fetches it on-demand for streaming.

---

## Learning API Restructure - Match deburnalpha Structure

Restructured the learning API to match the original deburnalpha API structure.

### Problem

The `/api/learning/modules` endpoint was using a transformed response format that didn't match what the frontend expected from deburnalpha. This caused field mapping issues and the frontend was calling a non-existent endpoint.

### Changes Made

**1. Renamed endpoint from `/modules` to `/content`**

The endpoint now matches deburnalpha:
- Old: `GET /api/learning/modules` → `{data: {modules: [...]}}`
- New: `GET /api/learning/content` → `{data: {items: [...]}}`

**2. Updated response to use original field names**

Now passes through original MongoDB field names instead of transforming:
- `titleEn`/`titleSv` instead of `title`
- `lengthMinutes` instead of `duration`
- `contentType` instead of `type`
- All original fields preserved

**3. Added `hasContent` computed field**

Frontend uses this to grey out cards without content:
- `text_article`: `true` if `textContentEn` is not empty
- `audio_article`/`audio_exercise`: `true` if `audioFileEn` exists
- `video_link`: `true` if `videoUrl` exists

**4. Added audio streaming endpoint**

New endpoint for the frontend audio player:
```
GET /api/learning/content/{content_id}/audio/{language}
```
- Returns audio binary data with appropriate Content-Type
- Supports `en` and `sv` languages
- Returns 404 if audio not found

**5. Switched to main database**

Content is now loaded from the main `deburn` database instead of `deburn-hub`:
- Added `_main_db` global and `get_main_db()` getter to `dependencies.py`
- Learning router uses `get_main_db()` to access `contentitems` collection

### Files Modified

**Backend:**
- `app_v2/dependencies.py` - Added main database getter
- `app_v2/routers/learning.py` - Complete rewrite
- `docs/refactor/systems/api/learning.md` - Updated API documentation

**Frontend:**
- `src/pages/Learning.jsx` - Updated API call and field mappings
- `src/components/learning/ArticleModal.jsx` - Updated field names
- `src/components/learning/AudioModal.jsx` - Updated field names and audio URL

### API Response Format

```json
{
  "success": true,
  "data": {
    "items": [
      {
        "id": "679abc123...",
        "contentType": "text_article",
        "category": "leadership",
        "titleEn": "Article Title",
        "titleSv": "Artikelrubrik",
        "lengthMinutes": 5,
        "audioFileEn": null,
        "audioFileSv": null,
        "textContentEn": "Full article text...",
        "textContentSv": "Fullständig artikeltext...",
        "videoUrl": null,
        "purpose": "Description",
        "sortOrder": 1,
        "hasContent": true
      }
    ]
  }
}
```

---

## Learning Content Router Fixes

Fixed the `/api/learning/content` endpoint not returning data.

### Issues Found

1. **Route conflict**: Both `content_router` and `learning_router` defined `GET /api/learning/content`. Since `content_router` was registered first in `api_v2.py`, it shadowed `learning_router`.

2. **ContentService collection name**: `ContentService` used `db["contentItems"]` (camelCase) but MongoDB collection is `contentitems` (lowercase).

3. **ContentService mode**: Defaulted to `file` mode instead of `database` mode.

### Fixes Applied

**`api_v2.py`**
- Removed `content_router` import and registration (learning_router handles `/api/learning` endpoints)

**`app_v2/services/content/content_service.py`**
- Fixed collection name from `contentItems` to `contentitems`

**`app_v2/routers/learning.py`**
- Changed from `get_main_db()` to `get_hub_db()` to use `deburn-hub` database

**`app_v2/dependencies.py`**
- Added `get_hub_db()` function to expose hub database

---

## Audio Streaming - Blob URL Approach

Fixed audio playback failing due to authentication issues with `<audio>` elements.

### Problem

The `<audio src={url}>` element makes plain GET requests without Authorization headers. The backend requires Bearer token authentication, so audio requests returned 401 Unauthorized.

### Solution

Instead of setting the audio `src` directly, the frontend now:
1. Fetches audio using `fetch()` with Authorization header
2. Converts response to blob
3. Creates blob URL with `URL.createObjectURL(blob)`
4. Sets blob URL as audio source
5. Cleans up blob URL on unmount

### Files Modified

**Frontend: `src/components/learning/AudioModal.jsx`**
- Added `audioSrc`, `loading`, `error` state
- Added `useEffect` to fetch audio with auth headers on mount
- Play button disabled while loading
- Shows loading/error states
- Cleanup blob URL on unmount

### Benefits
- Works across different domains (no cookie issues)
- Uses existing Bearer token authentication
- No CORS credential configuration needed
